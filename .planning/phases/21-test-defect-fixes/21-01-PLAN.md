---
phase: 21-test-defect-fixes
plan: 01
type: execute
---

<objective>
Fix test defects: add expect.assertions guards for silent pass-through, await un-awaited fs.writeFile, replace source-scanning tests with behavioral tests, add PDF magic byte validation.

Purpose: Ensure all tests make meaningful assertions and fail when they should. Eliminate false confidence from tests that silently pass.
Output: Corrected test assertions, behavioral DOCX tests, PDF byte validation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Auto-selected based on dependency graph:
@.planning/phases/17-error-handling-unification/17-01-SUMMARY.md
(After 17-01: DOCXResult simplified, convertToDOCX throws ConversionError, tests already updated for throw-based API)
@.planning/phases/20-silent-failure-fixes/20-01-SUMMARY.md
(After 20-01: findSoffice EACCES, loadHTML cause chains - affects expected error messages in tests)

# Test files (read before planning):
@tests/cli.test.ts
@tests/docx-converter.test.ts
@tests/e2e/conversion.test.ts

**Constraining decisions:**
- Phase 17: Throw-on-failure pattern (converters throw ConversionError, callers use try/catch)
- Phase 17: DOCXResult is { outputPath: string } - "if you got a result, it worked"
- Phase 19: findSoffice/verifyLibreOffice imported from src/utils/soffice.ts
- Phase 20: findSoffice throws on EACCES (not silent null)

**Findings addressed:**
- P1: CLI test silent pass-through (cli.test.ts:96-108) - missing expect.assertions(1)
- P1: Un-awaited fs.writeFile race condition (cli.test.ts:86)
- P2: DOCX tests scan source code instead of behavioral testing (docx-converter.test.ts:60-86)
- P2: E2E tests don't validate PDF magic bytes (e2e/conversion.test.ts)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix CLI test silent pass-through and un-awaited writeFile</name>
  <files>tests/cli.test.ts</files>
  <action>
**1a. Fix silent pass-through at lines 96-108:**

The test `'errors with helpful message for missing input'` uses try/catch but has no `expect.assertions()`. If execFileSync succeeds (doesn't throw), the test passes silently with zero assertions.

Add `expect.assertions(1)` at the top of the test body. This ensures vitest fails the test if no expect() was called:

```typescript
it('errors with helpful message for missing input', () => {
  expect.assertions(1);
  try {
    execFileSync('node', [CLI_PATH, 'does-not-exist.html'], {
      encoding: 'utf-8',
      stdio: 'pipe',
    });
  } catch (error: unknown) {
    const execError = error as { stderr?: string; message?: string };
    const stderr = execError.stderr || execError.message || '';
    expect(stderr).toMatch(/not found|INPUT_NOT_FOUND/i);
  }
});
```

**1b. Fix un-awaited fs.writeFile at line 86:**

The test `'errors on non-HTML file'` calls `fs.writeFile(tempFile, 'test content')` without `await`. This is a race condition - the file might not be written when execFileSync runs on the next line.

Add `await` and make the test function async:

Change line 83-93:
```typescript
it('errors on non-HTML file', async () => {
  const tempFile = path.join(OUTPUT_DIR, 'test.txt');
  await fs.writeFile(tempFile, 'test content');

  expect(() => {
    execFileSync('node', [CLI_PATH, tempFile], {
      encoding: 'utf-8',
      stdio: 'pipe',
    });
  }).toThrow();
});
```

Note: The `it` callback already has `async` in the current code? Verify. If it's already async, just add `await`. If not, make it async AND add await.

**What to avoid:**
- Do NOT restructure tests beyond fixing the specific defects
- Do NOT add expect.assertions to ALL tests - only the ones with silent pass-through (try/catch without guaranteed assertion)
- Do NOT change test names or descriptions
  </action>
  <verify>
`npm test` passes all tests.
Verify expect.assertions added: `grep "expect.assertions" tests/cli.test.ts` returns match.
Verify await added: `grep "await fs.writeFile" tests/cli.test.ts` returns match at the non-HTML test.
  </verify>
  <done>
- expect.assertions(1) guards the silent pass-through test
- fs.writeFile properly awaited (no race condition)
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace source-scanning DOCX tests with behavioral tests</name>
  <files>tests/docx-converter.test.ts</files>
  <action>
**2a. Remove source-scanning tests (lines 60-86):**

Two tests read source code files and check for import strings:
- `'source code uses execFile not shell-based execution'` (line 60)
- `'dependencies source code uses execFile'` (line 76)

These are fragile - they break on any import refactoring, don't actually verify behavior, and provide false confidence. Source scanning is a code review concern, not a test concern.

Delete both test cases (lines 60-86).

**2b. Replace with behavioral tests:**

Add behavioral tests that verify the DOCX converter's actual API contract. These should work regardless of whether LibreOffice is installed.

```typescript
it('rejects non-existent input file', async () => {
  const { convertToDOCX } = await import('../src/converters/docx-converter.js');

  await expect(
    convertToDOCX('/tmp/nonexistent-file.html', '/tmp/output.docx')
  ).rejects.toThrow();
});

it('convertHTMLFileToDOCX rejects non-existent input file', async () => {
  const { convertHTMLFileToDOCX } = await import('../src/converters/docx-converter.js');

  await expect(
    convertHTMLFileToDOCX('/tmp/nonexistent-file.html', '/tmp/output.docx')
  ).rejects.toThrow();
});
```

These test real behavior: passing a nonexistent file should throw (either from HTML parser or from LibreOffice). No source code scanning, no import checking, just API contracts.

**2c. Remove unused fs import:**

After removing source-scanning tests, `import * as fs from 'fs/promises'` at line 10 is unused. Remove it.

**What to avoid:**
- Do NOT delete the first 3 behavioral tests (lines 16-58) - they're good tests
- Do NOT add tests that require LibreOffice to be installed - keep tests runnable on CI without it
- Do NOT scan source code in any new test
  </action>
  <verify>
`npm test` passes all tests.
Verify no fs import: `grep "import.*fs" tests/docx-converter.test.ts` returns nothing.
Verify no readFile usage: `grep "readFile" tests/docx-converter.test.ts` returns nothing.
  </verify>
  <done>
- Source-scanning tests removed (2 tests deleted)
- Behavioral tests added for error paths (2 tests added)
- Unused fs import removed
- Net test count: same or +0 (replaced 2 with 2)
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Add PDF magic byte validation to E2E tests</name>
  <files>tests/e2e/conversion.test.ts</files>
  <action>
**3a. Add PDF magic byte validation to PDF conversion tests:**

The E2E PDF tests verify file size but never check that the output is actually a valid PDF. Add `%PDF-` header validation.

After each `convertToPDF` call that produces a file, read the first 5 bytes and verify:

For the 3 main PDF tests (lines 34-70: 'converts simple HTML to PDF', 'converts document with chapters to PDF', 'converts document with tables to PDF'):

Add after the existing `fs.stat` assertion:
```typescript
// Verify PDF magic bytes
const header = await fs.readFile(outputPath, { encoding: null });
expect(header.subarray(0, 5).toString('ascii')).toBe('%PDF-');
```

Note: Use `fs.readFile` + `subarray(0,5)` rather than reading the entire file. Actually, the file is already on disk from convertToPDF, and for E2E tests file size is reasonable (< 1MB). Reading the whole file is fine for a test. Alternatively, use a file handle with read(5 bytes) for efficiency - but simplicity wins in tests.

A simpler approach: read just the first bytes using a buffer:
```typescript
const fileHandle = await fs.open(outputPath, 'r');
const headerBuf = Buffer.alloc(5);
await fileHandle.read(headerBuf, 0, 5, 0);
await fileHandle.close();
expect(headerBuf.toString('ascii')).toBe('%PDF-');
```

Pick the simpler approach: just use `fs.readFile` and check `.subarray(0,5)`. E2E tests already do `fs.stat`, so full reads are fine.

Apply this to:
- 'converts simple HTML to PDF' (after line 44)
- 'converts document with chapters to PDF' (after line 57)
- 'converts document with tables to PDF' (after line 69)

Do NOT add to the SRS test (already skipIf gated).

**3b. Also add to the result.buffer check (optional refinement):**

For tests that check `result.buffer`, we can also verify the buffer starts with %PDF-:
```typescript
expect(result.buffer.subarray(0, 5).toString('ascii')).toBe('%PDF-');
```

Add this alongside the existing `result.buffer.length` checks for the same 3 tests.

**What to avoid:**
- Do NOT modify DOCX tests in this file
- Do NOT modify the skipIf conditions
- Do NOT add new test cases - just add assertions to existing ones
- Do NOT change test names or timeouts
  </action>
  <verify>
`npm test` passes all tests.
Verify magic byte checks: `grep "PDF-" tests/e2e/conversion.test.ts` returns matches.
  </verify>
  <done>
- PDF magic byte validation (%PDF-) added to 3 E2E PDF tests
- Both buffer and file checks validate PDF format
- All tests pass
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests
- [ ] `npm run typecheck` passes
- [ ] CLI test has expect.assertions(1) for silent pass-through case
- [ ] CLI test awaits fs.writeFile properly
- [ ] No source-scanning tests remain in docx-converter.test.ts
- [ ] E2E PDF tests validate %PDF- magic bytes
</verification>

<success_criteria>

- CLI silent pass-through test guarded with expect.assertions(1)
- fs.writeFile race condition fixed with await
- Source-scanning tests replaced with behavioral tests
- PDF magic byte validation added to E2E tests
- All tests pass
- Build clean
</success_criteria>

<output>
After completion, create `.planning/phases/21-test-defect-fixes/21-01-SUMMARY.md`
</output>
