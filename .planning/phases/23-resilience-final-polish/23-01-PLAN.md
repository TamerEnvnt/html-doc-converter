---
phase: 23-resilience-final-polish
plan: 01
type: execute
---

<objective>
Add SIGINT/SIGTERM handler for graceful browser cleanup, add compile-time exhaustiveness check in createError switch, and run final verification of the full Milestone 3 state.

Purpose: Prevent zombie Chromium processes on Ctrl+C, ensure new ErrorCodes get compile-time enforcement, and confirm all Milestone 3 work passes cleanly.
Output: Updated cli.ts with signal handlers, updated errors.ts with exhaustive switch, all tests passing.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key source files:
@src/cli.ts
@src/utils/errors.ts
@src/converters/pdf-converter.ts

**Tech stack available:** vitest, commander, puppeteer
**Established patterns:**
- closeBrowser() is safe in finally blocks (null-before-close, Phase 16)
- ConversionError with ErrorCodes (Phase 17)
- CLI imports closeBrowser from pdf-converter.ts

**Constraining decisions:**
- Phase 16: closeBrowser() silently discards close errors (safe for cleanup)
- Phase 17: Throw-on-failure pattern with ConversionError
- Phase 22: CLI helpers extracted to cli-helpers.ts (cli.ts is now ~267 lines)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SIGINT/SIGTERM graceful cleanup handler to cli.ts</name>
  <files>src/cli.ts, tests/cli.test.ts</files>
  <action>
Add signal handlers BEFORE `program.parse()` in cli.ts (around line 265):

```typescript
// Graceful cleanup on termination signals
const handleSignal = async (signal: string): Promise<void> => {
  verbose(`Received ${signal}, cleaning up...`);
  await closeBrowser();
  process.exit(128 + (signal === 'SIGINT' ? 2 : 15));
};

process.on('SIGINT', () => { handleSignal('SIGINT'); });
process.on('SIGTERM', () => { handleSignal('SIGTERM'); });
```

Key points:
- Exit codes follow Unix convention: 128 + signal number (SIGINT=2, SIGTERM=15)
- closeBrowser() is already safe (null-before-close pattern from Phase 16)
- verbose() logs the cleanup for debugging
- Handler calls closeBrowser() THEN exits, preventing zombie Chromium
- The arrow wrapper is needed because process.on expects synchronous callback

Add a test to cli.test.ts that verifies the signal handler doesn't crash on a clean process (no browser started). Use subprocess approach consistent with existing CLI tests:
- Spawn the CLI with a valid HTML file but immediately send SIGINT
- Verify exit code is 130 (128 + 2) OR that the process exits without error

Important: Do NOT test with actual Chromium/browser. Just verify the handler registers and doesn't throw on cleanup when no browser is running.
  </action>
  <verify>cd /Users/tamer/Work/AI/Claude/html-doc-converter && npm run build && npx vitest run tests/cli.test.ts</verify>
  <done>Signal handlers registered in cli.ts. Build passes. Existing CLI tests still pass. Signal handler test passes.</done>
</task>

<task type="auto">
  <name>Task 2: Add compile-time exhaustiveness check to createError switch</name>
  <files>src/utils/errors.ts, tests/utils/errors.test.ts</files>
  <action>
Modify the createError function in errors.ts to use TypeScript's `never` type for exhaustiveness checking.

Replace the current `default` case (lines 168-174):

```typescript
    default:
      return new ConversionError(
        detail || 'An unknown error occurred.',
        ErrorCodes.UNKNOWN,
        'Please report this issue with details.'
      );
```

With an exhaustive pattern that handles UNKNOWN explicitly:

```typescript
    case ErrorCodes.UNKNOWN:
      return new ConversionError(
        detail || 'An unknown error occurred.',
        code,
        'Please report this issue with details.'
      );

    default: {
      // Compile-time exhaustiveness check: if a new ErrorCode is added
      // without a case here, TypeScript will error on this line
      const _exhaustive: never = code;
      return new ConversionError(
        detail || 'An unexpected error occurred.',
        ErrorCodes.UNKNOWN,
        'Please report this issue with details.'
      );
    }
```

This way:
- UNKNOWN gets its own explicit case (using `code` instead of hardcoded `ErrorCodes.UNKNOWN`)
- The `default` branch uses `never` to catch missing cases at compile time
- If someone adds a new ErrorCode without a case, `tsc` will error: "Type 'X' is not assignable to type 'never'"
- Runtime still works (the return after `_exhaustive` acts as fallback)

Add a test to errors.test.ts verifying that all ErrorCodes have corresponding createError cases:

```typescript
it('createError handles all ErrorCode values', () => {
  for (const code of Object.values(ErrorCodes)) {
    const error = createError(code, 'test detail');
    expect(error).toBeInstanceOf(ConversionError);
    expect(error.code).toBe(code);
  }
});
```

This test ensures runtime behavior matches compile-time guarantee.
  </action>
  <verify>cd /Users/tamer/Work/AI/Claude/html-doc-converter && npm run build && npx vitest run tests/utils/errors.test.ts</verify>
  <done>createError has exhaustive switch. UNKNOWN has explicit case. Build passes (no missing cases). Error tests pass including new exhaustiveness test.</done>
</task>

<task type="auto">
  <name>Task 3: Final Milestone 3 verification</name>
  <files>vitest.config.ts</files>
  <action>
Run the complete verification suite:

1. `npm run build` - full TypeScript build
2. `npx vitest run` - full test suite
3. `npx vitest run --coverage` - coverage thresholds

Verify:
- All tests pass (should be 185+ total: 183 from Phase 22 + new tests from tasks 1-2)
- Coverage thresholds met (70% lines/functions/statements, 60% branches)
- No TypeScript errors
- No regressions from any Milestone 3 phase

Do NOT modify vitest.config.ts unless a threshold fails.

This is a verification-only task. No code changes expected.
  </action>
  <verify>cd /Users/tamer/Work/AI/Claude/html-doc-converter && npx vitest run --coverage 2>&1 | tail -30</verify>
  <done>Full suite passes. All coverage thresholds met. Milestone 3 ready for completion.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `npx vitest run` - all tests pass
- [ ] `npx vitest run --coverage` - thresholds met
- [ ] Signal handlers registered (SIGINT/SIGTERM)
- [ ] createError has exhaustive switch (verified by TypeScript compiler)
- [ ] Phase 23 complete = Milestone 3 complete
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Signal handlers prevent zombie Chromium on Ctrl+C
- createError enforces exhaustiveness at compile time
- Full Milestone 3 regression-free
- Phase 23 complete (last phase of Milestone 3)
  </success_criteria>

<output>
After completion, create `.planning/phases/23-resilience-final-polish/23-01-SUMMARY.md`
</output>
