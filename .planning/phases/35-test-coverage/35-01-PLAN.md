---
phase: 35-test-coverage
plan: 01
type: execute
---

<objective>
Fill 5 test gaps: isHeadingLevel direct tests, DOCX outputDir success path, mocked dependency version extraction, CLI --docx-only path, and partial failure exit code.

Purpose: These gaps were identified in the 5-agent review. Each represents untested behavior that could silently regress.
Output: 5 new test groups across 4 test files (1 new), all passing.
</objective>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/parsers/html-parser.ts
@src/utils/dependencies.ts
@src/utils/exec.ts
@src/converters/docx-converter.ts
@src/cli.ts
@tests/html-parser.test.ts
@tests/docx-converter-mocked.test.ts
@tests/utils/dependencies.test.ts
@tests/cli.test.ts
</context>

<tasks>
<task type="auto">
  <name>Task 1: Add isHeadingLevel, DOCX outputDir, and mocked dependency version tests</name>
  <files>tests/html-parser.test.ts, tests/docx-converter-mocked.test.ts, tests/utils/dependencies-mocked.test.ts (new)</files>
  <action>
  **tests/html-parser.test.ts — Add isHeadingLevel direct test block:**

  Import `isHeadingLevel` (add to the existing import from `../src/parsers/html-parser.js`).

  Add a new describe block after the existing ones (before the closing of the top-level describe):

  ```typescript
  describe('isHeadingLevel', () => {
    it('returns true for valid heading levels 1-6', () => {
      for (let i = 1; i <= 6; i++) {
        expect(isHeadingLevel(i)).toBe(true);
      }
    });

    it('returns false for 0', () => {
      expect(isHeadingLevel(0)).toBe(false);
    });

    it('returns false for 7', () => {
      expect(isHeadingLevel(7)).toBe(false);
    });

    it('returns false for negative numbers', () => {
      expect(isHeadingLevel(-1)).toBe(false);
    });

    it('returns false for non-integer numbers', () => {
      expect(isHeadingLevel(1.5)).toBe(false);
      expect(isHeadingLevel(2.7)).toBe(false);
    });

    it('returns false for NaN', () => {
      expect(isHeadingLevel(NaN)).toBe(false);
    });
  });
  ```

  **tests/docx-converter-mocked.test.ts — Add DOCX outputDir success path test:**

  Add a new test inside the `convertToDOCX - mocked` describe block (after existing tests):

  ```typescript
  it('uses custom outputDir when provided in options', async () => {
    const result = await convertToDOCX('/tmp/test.html', '/tmp/test.docx', {
      outputDir: '/custom/output',
    });

    expect(result).toEqual({ outputPath: path.resolve('/tmp/test.docx') });
    // Verify mkdir was called with the custom outputDir
    expect(mockedMkdir).toHaveBeenCalledWith('/custom/output', { recursive: true });
    // Verify execFile was called with --outdir pointing to custom dir
    const execArgs = mockedExecFile.mock.calls[0];
    expect(execArgs[1]).toContain('/custom/output');
  });
  ```

  **tests/utils/dependencies-mocked.test.ts — NEW FILE: Mocked version extraction tests:**

  Create a new test file with file-scoped mocks for puppeteer, soffice, and exec:

  ```typescript
  /**
   * Dependencies - Mocked Version Extraction Tests
   *
   * Tests checkChromium and checkLibreOffice version parsing
   * with mocked system calls for deterministic behavior.
   */

  import { describe, it, expect, vi, beforeEach } from 'vitest';

  vi.mock('puppeteer', () => ({
    default: {
      executablePath: vi.fn(),
    },
  }));

  vi.mock('../../src/utils/soffice.js', () => ({
    findSoffice: vi.fn(),
  }));

  vi.mock('../../src/utils/exec.js', () => ({
    execFileAsync: vi.fn(),
  }));

  // Suppress verbose logging in tests
  vi.mock('../../src/utils/logger.js', () => ({
    verbose: vi.fn(),
  }));

  // Mock platform for install instructions
  vi.mock('../../src/utils/platform.js', () => ({
    getPlatform: vi.fn(() => 'darwin'),
    getPlatformName: vi.fn(() => 'macOS'),
  }));

  import puppeteer from 'puppeteer';
  import { findSoffice } from '../../src/utils/soffice.js';
  import { execFileAsync } from '../../src/utils/exec.js';
  import { checkDependencies } from '../../src/utils/dependencies.js';

  const mockedPuppeteer = vi.mocked(puppeteer);
  const mockedFindSoffice = vi.mocked(findSoffice);
  const mockedExecFileAsync = vi.mocked(execFileAsync);

  describe('checkDependencies - mocked version extraction', () => {
    beforeEach(() => {
      vi.clearAllMocks();
    });

    describe('Chromium version extraction', () => {
      beforeEach(() => {
        // Default: LibreOffice found (focus tests on Chromium)
        mockedFindSoffice.mockResolvedValue('/usr/bin/soffice');
      });

      it('extracts Google Chrome version from --version output', async () => {
        mockedPuppeteer.executablePath.mockReturnValue('/usr/bin/chrome');
        mockedExecFileAsync.mockImplementation(async (cmd: any) => {
          if (String(cmd).includes('chrome')) {
            return { stdout: 'Google Chrome 120.0.6099.130', stderr: '' } as any;
          }
          return { stdout: 'LibreOffice 7.5.3', stderr: '' } as any;
        });

        const result = await checkDependencies();
        const chromium = result.dependencies.find(d => d.name.includes('Chromium'));

        expect(chromium?.found).toBe(true);
        if (chromium?.found) {
          expect(chromium.version).toBe('120.0.6099.130');
        }
      });

      it('extracts Chromium version from --version output', async () => {
        mockedPuppeteer.executablePath.mockReturnValue('/usr/bin/chromium');
        mockedExecFileAsync.mockImplementation(async (cmd: any) => {
          if (String(cmd).includes('chromium')) {
            return { stdout: 'Chromium 119.0.5962.0', stderr: '' } as any;
          }
          return { stdout: 'LibreOffice 7.5.3', stderr: '' } as any;
        });

        const result = await checkDependencies();
        const chromium = result.dependencies.find(d => d.name.includes('Chromium'));

        expect(chromium?.found).toBe(true);
        if (chromium?.found) {
          expect(chromium.version).toBe('119.0.5962.0');
        }
      });

      it('returns found=true with undefined version when --version fails', async () => {
        mockedPuppeteer.executablePath.mockReturnValue('/usr/bin/chrome');
        mockedExecFileAsync.mockImplementation(async (cmd: any) => {
          if (String(cmd).includes('chrome')) {
            throw new Error('--version not supported');
          }
          return { stdout: 'LibreOffice 7.5.3', stderr: '' } as any;
        });

        const result = await checkDependencies();
        const chromium = result.dependencies.find(d => d.name.includes('Chromium'));

        expect(chromium?.found).toBe(true);
        if (chromium?.found) {
          expect(chromium.version).toBeUndefined();
        }
      });

      it('returns found=false when puppeteer.executablePath() throws', async () => {
        mockedPuppeteer.executablePath.mockImplementation(() => {
          throw new Error('Could not find Chromium');
        });
        mockedExecFileAsync.mockResolvedValue({ stdout: 'LibreOffice 7.5.3', stderr: '' } as any);

        const result = await checkDependencies();
        const chromium = result.dependencies.find(d => d.name.includes('Chromium'));

        expect(chromium?.found).toBe(false);
      });
    });

    describe('LibreOffice version extraction', () => {
      beforeEach(() => {
        // Default: Chromium found (focus tests on LibreOffice)
        mockedPuppeteer.executablePath.mockReturnValue('/usr/bin/chrome');
      });

      it('extracts 3-part version', async () => {
        mockedFindSoffice.mockResolvedValue('/usr/bin/soffice');
        mockedExecFileAsync.mockImplementation(async (cmd: any) => {
          if (String(cmd).includes('soffice')) {
            return { stdout: 'LibreOffice 7.5.3 abc123', stderr: '' } as any;
          }
          return { stdout: 'Google Chrome 120.0.0', stderr: '' } as any;
        });

        const result = await checkDependencies();
        const lo = result.dependencies.find(d => d.name === 'LibreOffice');

        expect(lo?.found).toBe(true);
        if (lo?.found) {
          expect(lo.version).toBe('7.5.3');
        }
      });

      it('extracts 4-part version', async () => {
        mockedFindSoffice.mockResolvedValue('/usr/bin/soffice');
        mockedExecFileAsync.mockImplementation(async (cmd: any) => {
          if (String(cmd).includes('soffice')) {
            return { stdout: 'LibreOffice 24.2.0.3', stderr: '' } as any;
          }
          return { stdout: 'Google Chrome 120.0.0', stderr: '' } as any;
        });

        const result = await checkDependencies();
        const lo = result.dependencies.find(d => d.name === 'LibreOffice');

        expect(lo?.found).toBe(true);
        if (lo?.found) {
          expect(lo.version).toBe('24.2.0.3');
        }
      });

      it('returns found=true with undefined version when --version fails', async () => {
        mockedFindSoffice.mockResolvedValue('/usr/bin/soffice');
        mockedExecFileAsync.mockImplementation(async (cmd: any) => {
          if (String(cmd).includes('soffice')) {
            throw new Error('soffice --version failed');
          }
          return { stdout: 'Google Chrome 120.0.0', stderr: '' } as any;
        });

        const result = await checkDependencies();
        const lo = result.dependencies.find(d => d.name === 'LibreOffice');

        expect(lo?.found).toBe(true);
        if (lo?.found) {
          expect(lo.version).toBeUndefined();
        }
      });

      it('returns found=false when soffice not found', async () => {
        mockedFindSoffice.mockResolvedValue(null);
        mockedExecFileAsync.mockResolvedValue({ stdout: 'Google Chrome 120.0.0', stderr: '' } as any);

        const result = await checkDependencies();
        const lo = result.dependencies.find(d => d.name === 'LibreOffice');

        expect(lo?.found).toBe(false);
      });
    });
  });
  ```

  Adapt this structure if needed based on how vitest resolves the mocked modules. The key patterns:
  - `vi.mock()` at top of file (hoisted)
  - Import after mocks
  - `vi.mocked()` for typed access
  - `beforeEach(() => vi.clearAllMocks())` for isolation
  - Match on command path string to differentiate Chrome vs soffice calls

  Do NOT modify existing dependencies.test.ts — it has non-mocked integration tests that should stay.
  </action>
  <verify>npx tsc --noEmit && npx vitest run tests/html-parser.test.ts tests/docx-converter-mocked.test.ts tests/utils/dependencies-mocked.test.ts --reporter=verbose 2>&1 | tail -20</verify>
  <done>isHeadingLevel tested directly (6 tests). DOCX outputDir success path tested. Chromium/LibreOffice version extraction tested with mocks (8 tests). All pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI --docx-only path and partial failure exit code tests</name>
  <files>tests/cli.test.ts</files>
  <action>
  Add two new tests to the CLI test file using the ESM loader pattern already established in the "Check Command" tests (line 72-109).

  **Test 1: --docx-only path (inside "Full Conversion" describe block):**

  This test creates an ESM loader that mocks both converters and soffice to verify --docx-only skips PDF:

  ```typescript
  it('converts HTML file to DOCX with --docx-only', async () => {
    const inputPath = path.join(FIXTURES_DIR, 'simple.html');
    const outputBase = path.join(OUTPUT_DIR, 'docx-only-test');
    const projectRoot = path.join(__dirname, '..');

    // ESM loader: mock pdf-converter (should NOT be called), docx-converter (succeeds), soffice (found)
    const loaderScript = [
      `export async function load(url, context, nextLoad) {`,
      `  if (url.endsWith('pdf-converter.js')) {`,
      `    return {`,
      `      format: 'module',`,
      `      shortCircuit: true,`,
      `      source: [`,
      `        'export async function convertToPDF() { throw new Error("PDF should not be called"); }',`,
      `        'export async function convertHTMLFileToPDF() { throw new Error("should not be called"); }',`,
      `        'export async function convertHTMLStringToPDF() { throw new Error("should not be called"); }',`,
      `        'export async function closeBrowser() {}',`,
      `      ].join("\\n"),`,
      `    };`,
      `  }`,
      `  if (url.endsWith('docx-converter.js')) {`,
      `    return {`,
      `      format: 'module',`,
      `      shortCircuit: true,`,
      `      source: [`,
      `        'export async function convertToDOCX(input, output) { return { outputPath: output }; }',`,
      `        'export async function convertHTMLFileToDOCX() { return {}; }',`,
      `      ].join("\\n"),`,
      `    };`,
      `  }`,
      `  if (url.endsWith('soffice.js')) {`,
      `    return {`,
      `      format: 'module',`,
      `      shortCircuit: true,`,
      `      source: [`,
      `        'export async function findSoffice() { return "/usr/bin/soffice"; }',`,
      `        'export async function verifyLibreOffice() { return true; }',`,
      `      ].join("\\n"),`,
      `    };`,
      `  }`,
      `  return nextLoad(url, context);`,
      `}`,
    ].join('\n');

    const loaderPath = path.join(OUTPUT_DIR, 'docx-only-loader.mjs');
    await fs.writeFile(loaderPath, loaderScript);

    const output = execFileSync(
      'node',
      ['--loader', loaderPath, CLI_PATH, inputPath, '-o', outputBase, '--docx-only', '--force'],
      {
        encoding: 'utf-8',
        timeout: 30000,
        cwd: projectRoot,
        env: { ...process.env, NODE_NO_WARNINGS: '1' },
      }
    );

    // DOCX conversion should run
    expect(output).toContain('[DOCX]');
    expect(output).toContain('Done');
    // PDF should NOT run
    expect(output).not.toContain('[PDF]');
  }, 30000);
  ```

  **Test 2: Partial failure exit code 2 (new describe block "Exit Codes"):**

  Add a new describe block in the CLI test, after the existing blocks:

  ```typescript
  describe('Exit Codes', () => {
    it('exits with code 2 on partial failure (one format succeeds, one fails)', async () => {
      const inputPath = path.join(FIXTURES_DIR, 'simple.html');
      const outputBase = path.join(OUTPUT_DIR, 'partial-fail-test');
      const projectRoot = path.join(__dirname, '..');

      // ESM loader: PDF succeeds, DOCX fails, soffice verified
      const loaderScript = [
        `export async function load(url, context, nextLoad) {`,
        `  if (url.endsWith('pdf-converter.js')) {`,
        `    return {`,
        `      format: 'module',`,
        `      shortCircuit: true,`,
        `      source: [`,
        `        'export async function convertToPDF(input, output) { return { outputPath: output }; }',`,
        `        'export async function convertHTMLFileToPDF() { return {}; }',`,
        `        'export async function convertHTMLStringToPDF() { return {}; }',`,
        `        'export async function closeBrowser() {}',`,
        `      ].join("\\n"),`,
        `    };`,
        `  }`,
        `  if (url.endsWith('docx-converter.js')) {`,
        `    return {`,
        `      format: 'module',`,
        `      shortCircuit: true,`,
        `      source: [`,
        `        'export async function convertToDOCX() { throw new Error("mock DOCX failure"); }',`,
        `        'export async function convertHTMLFileToDOCX() { throw new Error("mock"); }',`,
        `      ].join("\\n"),`,
        `    };`,
        `  }`,
        `  if (url.endsWith('soffice.js')) {`,
        `    return {`,
        `      format: 'module',`,
        `      shortCircuit: true,`,
        `      source: [`,
        `        'export async function findSoffice() { return "/usr/bin/soffice"; }',`,
        `        'export async function verifyLibreOffice() { return true; }',`,
        `      ].join("\\n"),`,
        `    };`,
        `  }`,
        `  return nextLoad(url, context);`,
        `}`,
      ].join('\n');

      const loaderPath = path.join(OUTPUT_DIR, 'partial-fail-loader.mjs');
      await fs.writeFile(loaderPath, loaderScript);

      try {
        execFileSync(
          'node',
          ['--loader', loaderPath, CLI_PATH, inputPath, '-o', outputBase, '--force'],
          {
            encoding: 'utf-8',
            timeout: 30000,
            stdio: 'pipe',
            cwd: projectRoot,
            env: { ...process.env, NODE_NO_WARNINGS: '1' },
          }
        );
        expect.unreachable('Expected process to exit with non-zero code');
      } catch (error: unknown) {
        const execError = error as { status?: number; stdout?: string };
        expect(execError.status).toBe(2);
        // PDF succeeded, DOCX failed
        expect(execError.stdout).toContain('[PDF]');
        expect(execError.stdout).toContain('[DOCX]');
      }
    }, 30000);
  });
  ```

  Key patterns:
  - ESM loader pattern matches the existing `check` command error test (line 72-109)
  - Mock pdf-converter.js, docx-converter.js, and soffice.js via the loader
  - Use `--force` to avoid overwrite check
  - Use real fixture file (simple.html) for input validation
  - 30s timeout (no real browser/LibreOffice, so should be fast)
  - Set `NODE_NO_WARNINGS: '1'` to suppress experimental loader warnings

  Do NOT modify any existing tests. Only add new tests.
  </action>
  <verify>npx tsc --noEmit && npx vitest run tests/cli.test.ts --reporter=verbose 2>&1 | tail -20</verify>
  <done>--docx-only path tested (verifies no PDF, only DOCX). Partial failure exit code 2 tested (PDF succeeds, DOCX fails). All CLI tests pass.</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vitest run` — all tests pass (existing + new)
- [ ] `npx tsc --noEmit` — no TypeScript errors
- [ ] isHeadingLevel has 6 direct tests covering valid/invalid/edge cases
- [ ] DOCX outputDir success path tested with custom dir
- [ ] Chromium and LibreOffice version extraction tested with mocks (8 tests)
- [ ] CLI --docx-only path tested (DOCX runs, PDF does not)
- [ ] Partial failure exit code 2 tested (PDF succeeds, DOCX fails)
</verification>

<success_criteria>
- 5 test gaps addressed across 4 files (1 new)
- ~20 new tests added
- All existing tests still pass
- No TypeScript errors
- Test count increased from 194
</success_criteria>

<output>
After completion, create `.planning/phases/35-test-coverage/35-01-SUMMARY.md`
</output>
