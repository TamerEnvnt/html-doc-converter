---
phase: 03-pdf-converter
plan: 01
type: execute
---

<objective>
Convert HTML documents to PDF using Puppeteer with full CSS support including print styles, gradients, and colors.

Purpose: Create the PDF conversion pipeline that renders HTML with pixel-perfect fidelity using Chrome's print engine.
Output: Working PDF converter module that generates high-quality PDFs from HTML documents.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Depends on:** Phase 2 (HTML Parser) — document parsing and structure

**Reference document:** `/Users/tamer/Work/AI/Claude/InfraSizingCalculator/docs/srs/SRS_InfraSizingCalculator.html`

**SRS document CSS features that must render correctly:**
- Print-optimized CSS (`@page`, `@media print`)
- Gradient headers for use cases
- Color-coded boxes (requirements, alt flows, exceptions)
- Tables with alternating row colors
- A4 page sizing with specific margins

**Puppeteer page.pdf() key options (from Context7 research):**
- `format: 'A4'` — paper size
- `printBackground: true` — CRITICAL: renders gradients and background colors
- `preferCSSPageSize: true` — respects @page CSS rules
- `margin: { top, right, bottom, left }` — page margins
- `displayHeaderFooter: true` — optional header/footer
- `headerTemplate` / `footerTemplate` — HTML templates with special classes
- `scale: 1` — rendering scale (0.1 to 2)
- `timeout: 30000` — generation timeout

**CSS note:** Use `-webkit-print-color-adjust: exact` to force accurate color rendering.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Puppeteer browser management</name>
  <files>src/converters/pdf-converter.ts</files>
  <action>
    Create PDF converter module with browser lifecycle management:

    1. Define types:
       ```typescript
       interface PDFOptions {
         format?: 'A4' | 'Letter' | 'Legal';
         landscape?: boolean;
         margin?: {
           top?: string;
           right?: string;
           bottom?: string;
           left?: string;
         };
         printBackground?: boolean;
         preferCSSPageSize?: boolean;
         displayHeaderFooter?: boolean;
         headerTemplate?: string;
         footerTemplate?: string;
         scale?: number;
       }

       interface PDFResult {
         buffer: Buffer;
         pageCount?: number;
       }
       ```

    2. Create browser management:
       ```typescript
       let browserInstance: Browser | null = null;

       async function getBrowser(): Promise<Browser> {
         if (!browserInstance) {
           browserInstance = await puppeteer.launch({
             headless: true,
             args: ['--no-sandbox', '--disable-setuid-sandbox']
           });
         }
         return browserInstance;
       }

       async function closeBrowser(): Promise<void> {
         if (browserInstance) {
           await browserInstance.close();
           browserInstance = null;
         }
       }
       ```

    3. Browser singleton pattern prevents repeated launches (slow).
    4. Args needed for containerized/CI environments.
    5. Export closeBrowser() for cleanup.
  </action>
  <verify>Browser launches without errors; closeBrowser() works</verify>
  <done>Browser management functions implemented and tested</done>
</task>

<task type="auto">
  <name>Task 2: Implement PDF generation with print options</name>
  <files>src/converters/pdf-converter.ts</files>
  <action>
    Create main conversion function:

    ```typescript
    async function convertToPDF(
      htmlPath: string,
      outputPath: string,
      options: PDFOptions = {}
    ): Promise<PDFResult> {
      const browser = await getBrowser();
      const page = await browser.newPage();

      try {
        // Load HTML file with file:// protocol
        const absolutePath = path.resolve(htmlPath);
        await page.goto(`file://${absolutePath}`, {
          waitUntil: 'networkidle0'  // Wait for all resources
        });

        // Inject CSS to force exact color rendering
        await page.addStyleTag({
          content: `
            * {
              -webkit-print-color-adjust: exact !important;
              print-color-adjust: exact !important;
            }
          `
        });

        // Generate PDF with merged options
        const pdfOptions = {
          path: outputPath,
          format: options.format || 'A4',
          printBackground: options.printBackground ?? true,  // Default TRUE
          preferCSSPageSize: options.preferCSSPageSize ?? true,  // Respect @page
          landscape: options.landscape ?? false,
          margin: options.margin || {
            top: '0',
            right: '0',
            bottom: '0',
            left: '0'
          },
          displayHeaderFooter: options.displayHeaderFooter ?? false,
          headerTemplate: options.headerTemplate || '',
          footerTemplate: options.footerTemplate || '',
          scale: options.scale || 1,
        };

        const pdfBuffer = await page.pdf(pdfOptions);

        return {
          buffer: Buffer.from(pdfBuffer),
        };
      } finally {
        await page.close();  // Always close page, keep browser
      }
    }
    ```

    Key implementation notes:
    - `waitUntil: 'networkidle0'` ensures all CSS/images loaded
    - `printBackground: true` DEFAULT — critical for gradients
    - `preferCSSPageSize: true` DEFAULT — respects SRS @page rules
    - Margin default '0' lets CSS handle margins
    - Page closed after each conversion, browser reused
  </action>
  <verify>Convert SRS document to PDF; verify gradients and colors render</verify>
  <done>convertToPDF() generates PDF with correct styling from SRS document</done>
</task>

<task type="auto">
  <name>Task 3: Integrate with parser and export public API</name>
  <files>src/converters/pdf-converter.ts, src/index.ts</files>
  <action>
    1. Add convenience function that uses parser:
       ```typescript
       async function convertHTMLFileToPDF(
         htmlPath: string,
         outputPath: string,
         options?: PDFOptions
       ): Promise<{ document: ParsedDocument; pdf: PDFResult }> {
         // Parse document for metadata (optional enrichment)
         const document = await parseDocument(htmlPath);

         // Generate PDF
         const pdf = await convertToPDF(htmlPath, outputPath, options);

         return { document, pdf };
       }
       ```

    2. Add string-based conversion for programmatic use:
       ```typescript
       async function convertHTMLStringToPDF(
         html: string,
         outputPath: string,
         options?: PDFOptions
       ): Promise<PDFResult> {
         const browser = await getBrowser();
         const page = await browser.newPage();

         try {
           await page.setContent(html, { waitUntil: 'networkidle0' });

           // Same CSS injection and PDF generation as convertToPDF
           // ... (reuse logic)
         } finally {
           await page.close();
         }
       }
       ```

    3. Export from src/converters/pdf-converter.ts:
       - convertToPDF
       - convertHTMLFileToPDF
       - convertHTMLStringToPDF
       - closeBrowser
       - PDFOptions type
       - PDFResult type

    4. Update src/index.ts to re-export:
       ```typescript
       export * from './converters/pdf-converter.js';
       export * from './parsers/html-parser.js';
       ```

    5. Add import for path module at top of pdf-converter.ts
  </action>
  <verify>Import from index.ts works; all functions accessible</verify>
  <done>Full PDF API exported; integration with parser complete</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` compiles without errors
- [ ] Convert SRS document to PDF successfully
- [ ] PDF shows gradients and background colors correctly
- [ ] PDF respects A4 sizing from CSS @page rules
- [ ] Tables render with alternating row colors
- [ ] Browser cleanup works (no hanging processes)
- [ ] All exports accessible from index.ts
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- SRS document converts to PDF with full visual fidelity
- Ready for Phase 5 (CLI Interface) integration
</success_criteria>

<output>
After completion, create `.planning/phases/03-pdf-converter/03-01-SUMMARY.md`:

# Phase 3 Plan 1: PDF Converter Summary

**[Substantive one-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]
- [Key outcome 3]

## Files Created/Modified

- `src/converters/pdf-converter.ts` - Complete PDF conversion module
- `src/index.ts` - Updated exports

## Decisions Made

[Any decisions made during implementation]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for Phase 4: DOCX Converter and Phase 5: CLI Interface
- PDF conversion complete
- Browser management implemented
- Public API exported
</output>
