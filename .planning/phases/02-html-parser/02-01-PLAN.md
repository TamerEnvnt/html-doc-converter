---
phase: 02-html-parser
plan: 01
type: execute
---

<objective>
Parse HTML documents and extract structural information for conversion.

Purpose: Create a parser that understands HTML document structure (chapters, sections, headings, tables) so converters can process the content intelligently.
Output: Working HTML parser module that loads HTML files and extracts document structure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Depends on:** Phase 1 (Foundation) — project structure and dependencies

**Reference document:** `/Users/tamer/Work/AI/Claude/InfraSizingCalculator/docs/srs/SRS_InfraSizingCalculator.html`

**SRS document structure (from PROJECT.md):**
- Print-optimized CSS (`@page`, `@media print`)
- Gradient headers for use cases
- Color-coded boxes (requirements, alt flows, exceptions)
- Multi-level TOC with chapter hierarchy
- Tables with alternating row colors
- A4 page sizing with specific margins

**Tech available:**
- cheerio (installed in Phase 1) — jQuery-like DOM parsing for Node.js
- TypeScript with ES modules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HTML file loading and DOM parsing</name>
  <files>src/parsers/html-parser.ts</files>
  <action>
    Create HTML parser module with:

    1. `loadHTML(filePath: string): Promise<CheerioAPI>` function
       - Read HTML file from disk using fs/promises
       - Parse with cheerio.load()
       - Return cheerio instance for DOM manipulation

    2. `loadHTMLFromString(html: string): CheerioAPI` function
       - Parse HTML string directly
       - Useful for testing and programmatic use

    3. Define types:
       ```typescript
       interface ParsedDocument {
         title: string;
         chapters: Chapter[];
         metadata: DocumentMetadata;
         rawHTML: string;
       }

       interface Chapter {
         id: string;
         title: string;
         level: number;  // h1=1, h2=2, etc.
         content: string;
         children: Chapter[];
       }

       interface DocumentMetadata {
         author?: string;
         version?: string;
         date?: string;
         customFields: Record<string, string>;
       }
       ```

    Use cheerio's static API (not deprecated instance methods).
    Handle file not found errors gracefully with clear error messages.
  </action>
  <verify>Can load the reference SRS HTML file without errors</verify>
  <done>loadHTML() and loadHTMLFromString() functions work; types defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement chapter/section extraction logic</name>
  <files>src/parsers/html-parser.ts</files>
  <action>
    Add `extractChapters(doc: CheerioAPI): Chapter[]` function:

    1. Find all heading elements (h1, h2, h3, h4, h5, h6)
    2. Build hierarchical chapter structure:
       - h1 = top-level chapters
       - h2 = sections within chapters
       - h3+ = subsections

    3. For each heading:
       - Extract id attribute (or generate from text if missing)
       - Extract title text
       - Capture content between this heading and the next
       - Build parent-child relationships based on heading level

    4. Handle edge cases:
       - Documents starting with h2 (no h1)
       - Multiple h1 elements
       - Skipped heading levels (h1 → h3)

    The SRS document uses:
    - h1 for document title
    - h2 for major sections (Introduction, Use Cases, etc.)
    - h3 for subsections
    - h4 for individual use cases

    Return flat list AND nested structure (chapters have children array).
  </action>
  <verify>Extract chapters from SRS document; verify hierarchy is correct</verify>
  <done>extractChapters() returns correct hierarchical structure from SRS document</done>
</task>

<task type="auto">
  <name>Task 3: Implement document metadata extraction</name>
  <files>src/parsers/html-parser.ts</files>
  <action>
    Add `extractMetadata(doc: CheerioAPI): DocumentMetadata` function:

    1. Extract from `<head>`:
       - `<title>` tag
       - `<meta name="author">`
       - `<meta name="version">`
       - `<meta name="date">`
       - Any custom `<meta>` tags

    2. Extract from document body (SRS-specific):
       - Document control section (version, status, date)
       - Look for common patterns like "Version:", "Author:", "Date:"

    3. Create main `parseDocument(filePath: string): Promise<ParsedDocument>` function that:
       - Loads HTML
       - Extracts metadata
       - Extracts chapters
       - Returns complete ParsedDocument object

    4. Export public API from src/parsers/html-parser.ts:
       - parseDocument (main function)
       - loadHTML, loadHTMLFromString (utilities)
       - All types

    5. Update src/index.ts to re-export parser module
  </action>
  <verify>parseDocument() returns complete structure from SRS document with title, chapters, metadata</verify>
  <done>Full parsing pipeline works; exports available from index.ts</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` compiles without errors
- [ ] Can parse the reference SRS document
- [ ] Chapters extracted with correct hierarchy
- [ ] Metadata extracted (at least title)
- [ ] Types are properly exported
- [ ] No TypeScript errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Parser correctly handles the SRS document structure
- Ready for Phase 3 (PDF Converter) and Phase 4 (DOCX Converter)
</success_criteria>

<output>
After completion, create `.planning/phases/02-html-parser/02-01-SUMMARY.md`:

# Phase 2 Plan 1: HTML Parser Summary

**[Substantive one-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]
- [Key outcome 3]

## Files Created/Modified

- `src/parsers/html-parser.ts` - Complete HTML parsing module
- `src/index.ts` - Updated exports

## Decisions Made

[Any decisions made during implementation]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for Phase 3: PDF Converter and Phase 4: DOCX Converter
- HTML parsing complete
- Document structure available
- Types exported for converter modules
</output>
