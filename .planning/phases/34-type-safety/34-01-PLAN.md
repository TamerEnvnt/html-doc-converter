---
phase: 34-type-safety
plan: 01
type: execute
---

<objective>
Add readonly to html-parser types, name anonymous return types, and narrow CLIOptions.format.

Purpose: Stronger types catch mutation bugs at compile time, named types improve API discoverability, and constrained format types prevent invalid values from propagating silently.
Output: Readonly interfaces, named return types, narrowed union types. All existing tests pass.
</objective>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/parsers/html-parser.ts
@src/cli-helpers.ts
@src/cli.ts
@src/utils/dependencies.ts
@src/index.ts
</context>

<tasks>
<task type="auto">
  <name>Task 1: Add readonly to html-parser types and name validateInputFile return type</name>
  <files>src/parsers/html-parser.ts, src/cli-helpers.ts</files>
  <action>
  **html-parser.ts — Add readonly to Chapter (lines 20-26):**

  ```
  export interface Chapter {
    readonly id: string;
    readonly title: string;
    readonly level: HeadingLevel;
    readonly content: string;
    readonly children: Chapter[];
  }
  ```

  Note: `readonly children: Chapter[]` prevents reassignment (`chapter.children = [...]`) but ALLOWS `.push()` — this is intentional. The extractChapters function builds chapters by pushing to children arrays during construction, which works fine with property-level readonly. Use `Chapter[]` NOT `readonly Chapter[]` to keep `.push()` working in extractChapters.

  **html-parser.ts — Add readonly to DocumentMetadata (lines 28-33):**

  ```
  export interface DocumentMetadata {
    readonly author?: string;
    readonly version?: string;
    readonly date?: string;
    readonly customFields: Record<string, string>;
  }
  ```

  Same principle: `readonly customFields: Record<string, string>` prevents reassignment but allows key setting during construction in extractMetadata.

  **html-parser.ts — Add readonly to ParsedDocument (lines 35-40):**

  ```
  export interface ParsedDocument {
    readonly title: string;
    readonly chapters: Chapter[];
    readonly metadata: DocumentMetadata;
    readonly rawHTML: string;
  }
  ```

  **cli-helpers.ts — Name the validateInputFile return type (line 56):**

  Add a named interface above the function:

  ```
  export interface ValidatedInput {
    readonly fileSize: number;
    readonly content: string;
    readonly isLargeFile: boolean;
  }
  ```

  Then change the function signature from:
  `export async function validateInputFile(inputPath: string): Promise<{ fileSize: number; content: string; isLargeFile: boolean; }>`
  To:
  `export async function validateInputFile(inputPath: string): Promise<ValidatedInput>`

  Export `ValidatedInput` from `src/index.ts` in the error types section (it's a public API type). Add it alongside the existing type exports at the bottom of the file:
  `export type { ValidatedInput } from './cli-helpers.js';`

  Do NOT change any logic. This is a pure type refactoring.
  </action>
  <verify>npx tsc --noEmit && npx vitest run tests/html-parser.test.ts tests/cli-helpers.test.ts --reporter=verbose 2>&1 | tail -10</verify>
  <done>All 13 html-parser fields have readonly. validateInputFile return type is named ValidatedInput. Tests pass. TypeScript clean.</done>
</task>

<task type="auto">
  <name>Task 2: Narrow CLIOptions.format and document DependencyCheckResult.allFound</name>
  <files>src/cli.ts, src/utils/dependencies.ts</files>
  <action>
  **cli.ts — Create OutputFormat type and narrow CLIOptions.format (lines 38-47):**

  Add a type alias above CLIOptions:

  ```
  type OutputFormat = 'pdf' | 'docx' | 'both';
  ```

  Then change CLIOptions:
  `format?: string;` → `format?: OutputFormat;`

  This is safe because:
  - Commander passes the value from `.option('-f, --format <format>', ...)` as a string
  - TypeScript's `string` is assignable to `OutputFormat` at the Commander boundary (Commander types its options broadly)
  - The runtime validation in `determineFormats()` already handles invalid values by checking exact matches and throwing INVALID_FORMAT
  - If TypeScript complains about the Commander assignment, the CLIOptions type is only used in the `.action()` callback parameter annotation — Commander doesn't enforce it at the type level, so the narrowing is purely for documentation and downstream usage

  If `tsc` complains about Commander's string not being assignable to OutputFormat, use a type assertion in the action callback parameter: `options: CLIOptions` stays as-is (Commander's type inference is loose enough). If it still fails, keep `format?: string` but add the `OutputFormat` type and use it in `determineFormats` parameter type instead. Test with `tsc --noEmit` before committing.

  **dependencies.ts — Document DependencyCheckResult.allFound (line 38-41):**

  The `allFound` field is already `readonly` (from Phase 32). The finding notes it's "derived/redundant" since it can be computed from `dependencies`. However:
  - Removing it would break the public API
  - It's readonly, so it can't get out of sync after creation
  - It's a useful convenience for consumers

  Add a JSDoc comment to document the derivation:

  ```
  export interface DependencyCheckResult {
    /** Derived: true when all required dependencies are found. Convenience field — equivalent to `dependencies.every(d => d.found || !d.required)`. */
    readonly allFound: boolean;
    readonly dependencies: readonly DependencyStatus[];
  }
  ```

  Do NOT change any logic. This is a pure type/documentation refactoring.
  </action>
  <verify>npx tsc --noEmit && npx vitest run --reporter=verbose 2>&1 | tail -5</verify>
  <done>CLIOptions.format narrowed to OutputFormat union. DependencyCheckResult.allFound documented as derived. All tests pass. TypeScript clean.</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vitest run` — all tests pass
- [ ] `npx tsc --noEmit` — no TypeScript errors
- [ ] All 13 html-parser fields have `readonly`
- [ ] ValidatedInput type is named and exported
- [ ] CLIOptions.format uses OutputFormat union
- [ ] DependencyCheckResult.allFound has JSDoc explaining derivation
</verification>

<success_criteria>
- 4 findings addressed across 4 files (+ 1 index.ts type export)
- All html-parser interfaces have readonly properties
- Anonymous return type replaced with named ValidatedInput
- CLIOptions.format constrained to union type
- DependencyCheckResult.allFound documented as derived convenience field
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-type-safety/34-01-SUMMARY.md`
</output>
