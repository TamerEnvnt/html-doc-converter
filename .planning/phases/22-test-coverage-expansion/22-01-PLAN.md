---
phase: 22-test-coverage-expansion
plan: 01
type: execute
---

<objective>
Add comprehensive mocked tests for the three PDF converter public API functions: convertToPDF, convertHTMLFileToPDF, and convertHTMLStringToPDF.

Purpose: These functions are the primary public API for PDF conversion but have zero test coverage. The existing pdf-converter.test.ts only tests browser management (getBrowser/closeBrowser).
Output: Expanded pdf-converter.test.ts with deterministic mocked tests covering success paths, option passing, timeout error handling, and return shapes.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-test-defect-fixes/21-01-SUMMARY.md

# Key source files:
@src/converters/pdf-converter.ts
@tests/pdf-converter.test.ts
@src/parsers/html-parser.ts

**Tech stack available:** vitest, puppeteer (mocked)
**Established patterns:**
- Puppeteer mock pattern (createMockBrowser, createMockPage) already in pdf-converter.test.ts
- expect.assertions guard on try/catch tests (Phase 21)
- Behavioral testing over source scanning (Phase 21)

**Constraining decisions:**
- Phase 16: Browser singleton pattern with promise lock
- Phase 17: All converters throw ConversionError (no success/error booleans)
- Phase 20: Timeout errors use ErrorCodes.TIMEOUT with specific messages
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add convertToPDF mocked tests</name>
  <files>tests/pdf-converter.test.ts</files>
  <action>
Add a new `describe('convertToPDF')` block to the existing test file. Import `convertToPDF` alongside the existing imports.

Tests to add:
1. **Success path**: Mock page.goto + page.pdf to return a Buffer. Call convertToPDF with a fixture path and '/tmp/test.pdf'. Assert result has `buffer` property that is a Buffer.
2. **Options passing**: Call with custom options (format: 'Letter', landscape: true, margin, scale). Verify page.pdf was called with those options merged in. Use `expect(mockPage.pdf).toHaveBeenCalledWith(expect.objectContaining({...}))`.
3. **Default options**: Call with no options. Verify page.pdf receives defaults (format: 'A4', printBackground: true, preferCSSPageSize: true, landscape: false, margin all '0').
4. **Navigation timeout**: Mock page.goto to throw an error with `name: 'TimeoutError'`. Use expect.assertions(1). Verify it throws ConversionError with code TIMEOUT.
5. **PDF generation timeout**: Mock page.pdf to throw TimeoutError. Verify ConversionError TIMEOUT.
6. **Page always closed**: Mock page.pdf to throw. Verify page.close was still called (finally block).

The mock page needs file:// URL handling: mock page.goto to accept any URL starting with `file://`.

Important: Reuse the existing mockBrowser/mockPage factories. The test file already mocks puppeteer at module level. Add convertToPDF to the import from '../src/converters/pdf-converter.js'.
  </action>
  <verify>cd /Users/tamer/Work/AI/Claude/html-doc-converter && npx vitest run tests/pdf-converter.test.ts</verify>
  <done>6+ new tests in convertToPDF describe block, all passing</done>
</task>

<task type="auto">
  <name>Task 2: Add convertHTMLFileToPDF and convertHTMLStringToPDF mocked tests</name>
  <files>tests/pdf-converter.test.ts</files>
  <action>
Add two new `describe` blocks:

**convertHTMLFileToPDF tests:**
1. **Success path**: Need to mock `parseDocument` from html-parser. Use `vi.mock('../src/parsers/html-parser.js')` at module level. Mock parseDocument to return a fake ParsedDocument. Call convertHTMLFileToPDF. Assert result has both `document` (ParsedDocument) and `pdf` (PDFResult with buffer).
2. **Propagates parse errors**: Mock parseDocument to throw. Verify error propagates.

Note: convertHTMLFileToPDF is a thin wrapper that calls parseDocument + convertToPDF. The mocking approach: mock parseDocument, let convertToPDF use the existing puppeteer mocks.

**convertHTMLStringToPDF tests:**
1. **Success path**: Call with '<html><body>Hello</body></html>' and output path. Mock page.setContent (already mocked). Assert buffer returned.
2. **Options passing**: Verify setContent receives timeout option. Verify page.pdf receives format/margin options.
3. **Content timeout**: Mock page.setContent to throw TimeoutError. Verify ConversionError TIMEOUT.
4. **Page always closed**: Mock page.pdf to throw. Verify page.close called.

Important: When mocking html-parser, be careful not to break other tests. Use `vi.mock` with factory that returns mocked parseDocument but passes through other exports. Or use `vi.spyOn` if possible.
  </action>
  <verify>cd /Users/tamer/Work/AI/Claude/html-doc-converter && npx vitest run tests/pdf-converter.test.ts</verify>
  <done>6+ new tests across both describe blocks, all passing. Total pdf-converter.test.ts tests: 18+</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vitest run tests/pdf-converter.test.ts` - all tests pass
- [ ] `npx vitest run` - full suite still passes (no regressions)
- [ ] convertToPDF has tests for: success, options, defaults, nav timeout, pdf timeout, page cleanup
- [ ] convertHTMLFileToPDF has tests for: success shape, parse error propagation
- [ ] convertHTMLStringToPDF has tests for: success, options, content timeout, page cleanup
</verification>

<success_criteria>

- All new tests pass
- No regressions in existing test suite
- PDF converter public API functions have meaningful unit test coverage
- Tests are deterministic (fully mocked, no Puppeteer/Chromium dependency)
  </success_criteria>

<output>
After completion, create `.planning/phases/22-test-coverage-expansion/22-01-SUMMARY.md`
</output>
