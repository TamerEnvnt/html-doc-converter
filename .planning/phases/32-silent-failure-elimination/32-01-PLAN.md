---
phase: 32-silent-failure-elimination
plan: 01
type: execute
---

<objective>
Distinguish expected from unexpected errors in catch blocks across soffice, dependencies, platform, and docx-converter.

Purpose: Bare catch blocks hide system errors (EPERM, EMFILE, EIO, corrupted installs) behind misleading messages ("not found", "not installed"). Discriminating error types surfaces real problems while keeping correct behavior for expected failures.
Output: Tighter catch blocks with verbose logging for unexpected errors, upgraded platform warning, fixed version regex.
</objective>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/utils/soffice.ts
@src/utils/dependencies.ts
@src/utils/platform.ts
@src/converters/docx-converter.ts
</context>

<tasks>
<task type="auto">
  <name>Task 1: Tighten error handling in soffice.ts and platform.ts</name>
  <files>src/utils/soffice.ts, src/utils/platform.ts</files>
  <action>
  **soffice.ts — findSoffice() fs.access catch (lines 46-52):**

  The EACCES case is already handled (throws). Tighten the remaining catch to only continue on ENOENT, and log unexpected errors at verbose:

  ```
  } catch (err) {
    const code = (err as NodeJS.ErrnoException).code;
    if (code === 'EACCES') {
      throw new Error(`LibreOffice found at ${p} but lacks execute permission`);
    }
    if (code !== 'ENOENT') {
      verbose(`Unexpected error checking ${p}:`, code || (err instanceof Error ? err.message : String(err)));
    }
    continue;
  }
  ```

  Add `import { verbose } from './logger.js';` at the top (alongside existing imports).

  **soffice.ts — findSoffice() which/where catch (lines 56-62):**

  Replace the bare catch with error discrimination. The `which`/`where` command exits with code 1 when not found — that's expected. Other errors (EPERM, EMFILE, ENOMEM) are unexpected:

  ```
  } catch (err) {
    // Exit code 1 = not found (expected), other errors are unexpected
    const isNotFound = err instanceof Error && 'code' in err &&
      ((err as NodeJS.ErrnoException).code === 'ENOENT' ||
       (err as { code?: string | number }).code === 1);
    if (!isNotFound) {
      verbose('Unexpected error in soffice PATH lookup:', err instanceof Error ? err.message : String(err));
    }
    return null;
  }
  ```

  Note: execFileAsync rejects with an error that has a numeric `code` property (the exit code) when the child process exits non-zero, and an `ENOENT` string code when the binary itself doesn't exist.

  **platform.ts — getPlatform() (line 27):**

  Replace `verbose(...)` with `console.warn(...)` so users see the fallback without needing --verbose. This is noteworthy — running on an unsupported platform in "linux mode" silently could cause confusing behavior:

  ```
  console.warn(`Warning: Unknown platform '${p}', falling back to Linux paths`);
  ```

  Keep the verbose import for other potential uses, but if it's the only use, remove the import.
  </action>
  <verify>npx tsc --noEmit && npx vitest run tests/soffice.test.ts tests/platform.test.ts --reporter=verbose 2>&1 | tail -10</verify>
  <done>findSoffice() catch blocks discriminate ENOENT from unexpected errors. which/where catch discriminates exit-code-1 from system errors. Platform fallback uses console.warn. Tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Fix Chromium catch-all and LibreOffice version regex in dependencies.ts</name>
  <files>src/utils/dependencies.ts, src/converters/docx-converter.ts</files>
  <action>
  **dependencies.ts — checkChromium() outer catch (lines 115-117):**

  Replace bare `catch {}` with verbose logging. The catch covers `puppeteer.executablePath()` failures — these could be corrupted installs, not just "missing":

  ```
  } catch (err) {
    verbose('Chromium detection error:', err instanceof Error ? err.message : String(err));
  }
  ```

  Add `import { verbose } from './logger.js';` at top of file.

  **dependencies.ts — checkChromium() inner version catch (lines 109-111):**

  Same treatment — add verbose logging:

  ```
  } catch (err) {
    verbose('Chromium version detection failed:', err instanceof Error ? err.message : String(err));
  }
  ```

  **dependencies.ts — checkLibreOffice() version regex (line 132):**

  Change from 3-part to support optional 4th part:

  Before: `/LibreOffice\s+(\d+\.\d+\.\d+)/`
  After:  `/LibreOffice\s+(\d+\.\d+\.\d+(?:\.\d+)?)/`

  **dependencies.ts — checkLibreOffice() version catch (lines 136-138):**

  Add verbose logging:

  ```
  } catch (err) {
    verbose('LibreOffice version detection failed:', err instanceof Error ? err.message : String(err));
  }
  ```

  **docx-converter.ts — fs.access catch (lines 85-89):**

  Distinguish "file not found" from permission/IO errors:

  ```
  try {
    await fs.access(generatedPath);
  } catch (err) {
    const code = (err as NodeJS.ErrnoException).code;
    if (code === 'EACCES' || code === 'EPERM') {
      throw createError(ErrorCodes.DOCX_FAILED, 'Output file created but not accessible (permission denied): ' + generatedPath);
    }
    throw createError(ErrorCodes.DOCX_FAILED, 'LibreOffice completed but output file not found: ' + generatedPath);
  }
  ```

  Do NOT change any other logic in these files.
  </action>
  <verify>npx tsc --noEmit && npx vitest run tests/dependencies.test.ts tests/docx-converter.test.ts --reporter=verbose 2>&1 | tail -10</verify>
  <done>Chromium detection catch logs at verbose level. Version regex supports 4-part versions. LibreOffice version catch logs. docx-converter fs.access distinguishes EACCES. Tests pass.</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vitest run` — all tests pass
- [ ] `npx tsc --noEmit` — no TypeScript errors
- [ ] No bare `catch {}` blocks remain in soffice.ts, dependencies.ts, or docx-converter.ts
- [ ] Platform fallback uses console.warn (not verbose)
- [ ] LibreOffice version regex matches 4-part versions
</verification>

<success_criteria>
- 5 findings addressed across 4 files
- All catch blocks either log at verbose level or discriminate error types
- All existing tests pass
- No new TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/32-silent-failure-elimination/32-01-SUMMARY.md`
</output>
