---
phase: 16-browser-singleton-hardening
plan: 01
type: execute
---

<objective>
Fix three P0 critical bugs in browser singleton management: race condition in getBrowser(), missing crash recovery, and error masking in closeBrowser().

Purpose: Prevent concurrent Puppeteer launches (resource leak + port conflicts), recover from Chromium crashes without stale references, and ensure closeBrowser() is safe in finally blocks.
Output: Hardened browser management in pdf-converter.ts with comprehensive tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Source file (267 lines - browser management at lines 42-65):
@src/converters/pdf-converter.ts

# Existing test patterns:
@tests/utils/logger.test.ts (for vi.spyOn / mock patterns)

# Error types (for potential ConversionError usage):
@src/utils/errors.ts

**Constraining decisions:**
- Phase 03: Browser singleton pattern established (puppeteer.launch with headless:true, --no-sandbox)
- Phase 10: Timeout support added (options.timeout passed to navigation/PDF generation)
- Phase 14: Vitest with v8 coverage, thresholds at 70%/60%

**Findings addressed (all P0):**
1. getBrowser() race condition: concurrent calls can launch multiple browsers (lines 47-54)
2. No crash recovery: stale browserInstance after Chromium crash, no `disconnected` handler
3. closeBrowser() masks errors in finally blocks: if `close()` throws, `browserInstance = null` never runs (lines 60-65)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden browser singleton with launch lock, crash recovery, and safe close</name>
  <files>src/converters/pdf-converter.ts</files>
  <action>
Replace the browser management section (lines 42-65) with three fixes:

**Fix 1 - Race condition (promise-based lock):**
- Add a `browserLaunchPromise: Promise<Browser> | null = null` variable alongside `browserInstance`
- In `getBrowser()`: if `browserLaunchPromise` exists, await and return it (deduplicates concurrent calls). If `browserInstance` exists and `browser.isConnected()`, return it. Otherwise, set `browserLaunchPromise = puppeteer.launch(...)`, await it, assign to `browserInstance`, clear `browserLaunchPromise`, return browser.
- Wrap the launch in try-catch: on failure, clear `browserLaunchPromise` so next call retries (don't leave a rejected promise cached).

**Fix 2 - Crash recovery (disconnected handler):**
- After successful launch, register `browser.on('disconnected', () => { browserInstance = null; browserLaunchPromise = null; })`. This auto-clears stale references if Chromium crashes or is killed.
- The `isConnected()` check in getBrowser() also catches stale references (belt-and-suspenders).

**Fix 3 - Safe closeBrowser():**
- Wrap `await browserInstance.close()` in try-catch. In the finally block (of closeBrowser's own try-catch), always set `browserInstance = null` and `browserLaunchPromise = null`. This ensures cleanup even if `close()` throws.
- Log the swallowed close error via verbose() if available, or silently discard (closeBrowser is cleanup code - failing loudly defeats its purpose in finally blocks).

**What to avoid:**
- Do NOT use a mutex/semaphore library - a simple promise variable is sufficient for this single-process use case.
- Do NOT change the function signatures (getBrowser returns Promise<Browser>, closeBrowser returns Promise<void>) - these are internal but called from 3 locations.
- Do NOT modify the PDF generation functions (convertToPDF, convertHTMLFileToPDF, convertHTMLStringToPDF) - they use getBrowser() which will transparently improve.
  </action>
  <verify>
`npm run build` succeeds with no TypeScript errors.
`npm test` passes all 134 existing tests (no regressions).
  </verify>
  <done>
- `browserLaunchPromise` prevents concurrent launches
- `browser.on('disconnected')` clears stale references
- `browser.isConnected()` check before reuse
- `closeBrowser()` always nulls references even if `close()` throws
- All existing tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add browser management tests</name>
  <files>tests/pdf-converter.test.ts</files>
  <action>
Create new test file `tests/pdf-converter.test.ts` testing browser management behavior. Mock puppeteer at the module level using `vi.mock('puppeteer')`.

**Test cases to write:**

1. **getBrowser returns same instance on sequential calls** - Call getBrowser (via convertHTMLStringToPDF or export for testing), verify puppeteer.launch called once.

2. **getBrowser deduplicates concurrent calls** - Call getBrowser twice without awaiting first. Both should resolve to same browser. puppeteer.launch called exactly once.

3. **closeBrowser is safe when no browser exists** - Call closeBrowser() when no browser has been launched. Should not throw.

4. **closeBrowser nulls instance even if close() throws** - Mock browser.close() to reject. Call closeBrowser(). Should not throw. Next getBrowser() should launch a new browser (proving instance was nulled).

5. **getBrowser launches new browser after disconnect** - Launch browser, simulate disconnect event (trigger the 'disconnected' callback), then call getBrowser() again. Should launch a new browser.

6. **getBrowser retries after failed launch** - First puppeteer.launch rejects, second succeeds. First getBrowser() should reject. Second getBrowser() should succeed with new launch (proving browserLaunchPromise was cleared on failure).

**Mock setup:**
- Mock puppeteer module: `vi.mock('puppeteer', () => ({ default: { launch: vi.fn() } }))`
- Create mock browser object with: `close: vi.fn()`, `isConnected: vi.fn().mockReturnValue(true)`, `on: vi.fn()`, `newPage: vi.fn()`
- Create mock page object with: `setViewport: vi.fn()`, `setContent: vi.fn()`, `goto: vi.fn()`, `addStyleTag: vi.fn()`, `pdf: vi.fn().mockResolvedValue(Buffer.from(''))`, `close: vi.fn()`
- Use `beforeEach` to reset mocks and call closeBrowser() to ensure clean state between tests

**What to avoid:**
- Do NOT test PDF generation logic (that's Phase 22's scope)
- Do NOT import getBrowser directly if it's not exported - test through public API (convertHTMLStringToPDF) or export it with a `/** @internal */` JSDoc tag for testing. Prefer: add a `_testing` named export object `{ getBrowser, resetBrowser }` guarded by NODE_ENV check - actually, simplest approach: just export getBrowser since it's already used internally and callers can benefit from it. The function is useful for advanced library consumers.
- Actually, the cleanest approach: export getBrowser and closeBrowser (closeBrowser already exported). Just add export to getBrowser. This is a legitimate API for consumers who want to manage the browser lifecycle.
  </action>
  <verify>
`npm test` passes all tests including new browser management tests.
`npm run build` still succeeds.
New test file has at least 6 test cases covering all 3 P0 findings.
  </verify>
  <done>
- 6+ tests covering: singleton reuse, concurrent dedup, safe close (no browser), safe close (throws), disconnect recovery, failed launch retry
- All tests pass
- No regressions in existing 134 tests
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests (134 existing + new browser tests)
- [ ] `npm run typecheck` passes
- [ ] Concurrent getBrowser() calls return same promise (tested)
- [ ] closeBrowser() safe in finally blocks (tested)
- [ ] Stale browser references auto-cleared on disconnect (tested)
</verification>

<success_criteria>

- All 3 P0 findings resolved
- Browser management hardened with launch lock, crash recovery, safe close
- 6+ new tests covering browser management behavior
- All verification checks pass
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/16-browser-singleton-hardening/16-01-SUMMARY.md`:

---
phase: 16-browser-singleton-hardening
plan: 01
subsystem: converter
tags: [puppeteer, browser, singleton, concurrency, crash-recovery]

requires:
  - phase: 03-pdf-converter
    provides: browser singleton pattern
provides:
  - Race-safe getBrowser() with promise lock
  - Crash recovery via disconnected handler
  - Safe closeBrowser() for finally blocks
  - getBrowser() exported for library consumers
affects: [17-error-handling-unification, 22-test-coverage-expansion]

tech-stack:
  added: []
  patterns: [promise-lock-pattern, disconnected-handler]

key-files:
  created: [tests/pdf-converter.test.ts]
  modified: [src/converters/pdf-converter.ts]
---

# Phase 16 Plan 01: Browser Singleton Hardening Summary

**[one-liner]**

## Accomplishments
## Files Created/Modified
## Decisions Made
## Issues Encountered
## Next Step
</output>
